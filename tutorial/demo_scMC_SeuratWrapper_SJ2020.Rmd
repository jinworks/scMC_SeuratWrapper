
---
title: "Demo of scMC SeuratWrapper using mouse skin dermis scRNA-seq data "
author: "Lihua Zhang"
output: html_document
mainfont: Arial
vignette: >
  %\VignetteIndexEntry{Integrating and comparing multiple single cell genomic datasets using scMC Seurat Wrapper}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  root.dir = './'
)
```

We showcase scMCâ€™s capability of detecting context-shared and -specific biological signals by applying it to two mouse skin scRNA-seq datasets containing cells from control and Hedgehog (Hh) activation conditions during skin wound healing. 


## Load the required libraries
```{r message=FALSE,warning=FALSE}
library(scMC)
library(Seurat)
library(patchwork)
library(dplyr)
library(ggplot2)
```

## Load data
scMC takes a list of multiple digital data matrices as input. Features should be in rows and cells in columns. Rownames and colnames should be included.

The scRNA datasets we demonstrated here, including two count data matrices for the control and Hh activation conditions, can be downloaded via this shared Google Drive [link](https://drive.google.com/file/d/182EMDA0x5fr2nV7MbC4SDISSjFBS1E0p/view?usp=sharing).

```{r}
load("/Users/suoqinjin/Documents/scMC_SeuratWrapper/tutorial/data_dermis.rda")
data.input <- data_dermis # a list of count data matrix, one per dataset
sample.name <- names(data.input)
```

# Part I: Setup the a list of Seurat objects, one per dataset
```{r}
object.list <- vector("list", length(sample.name))
names(object.list) <- sample.name
for (i in 1:length(object.list)) {
  # Initialize the Seurat object with the raw (non-normalized data) for each dataset
  x <- CreateSeuratObject(counts = data.input[[i]], min.cells = 3, min.features = 200, project = sample.name[i])
  # calculate mitochondrial QC metrics
  x[["percent.mt"]] <- PercentageFeatureSet(x, pattern = "^mt-")
  x$sample.name <- sample.name[i]
  x <- RenameCells(x, new.names = paste0(Cells(x), "_", x$sample.name))
  object.list[[i]] <-  x
  rm(x)
}
lapply(object.list, function(x) dim(x@assays$RNA@data))
```

## Step1. pre-processing each dataset
###  QC and selecting cells for further analysis
```{r}
nFeature_RNA1 = c(7000, 7000); nCount_RNA1 = c(40000, 40000); percent.mt1 = c(10, 10)
for (i in 1:length(object.list)) {
  # Visualize QC metrics as a violin plot
  gg <- VlnPlot(object.list[[i]], features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0.0001,cols=c("#a6cee3")) + geom_hline(yintercept = percent.mt1[i], linetype = 2)
  print(gg)
  cowplot::save_plot(filename=paste0("QC1_", sample.name[i],"_.pdf"), plot=gg, base_width = 7, base_height = 4.5)
 # VlnPlot(object.list[[i]], features = c("percent.mt"))+ geom_hline(yintercept = 15, linetype = 2)
  Sys.sleep(2)
  plot1 <- FeatureScatter(object.list[[i]], feature1 = "nCount_RNA", feature2 = "percent.mt", pt.size = 0.1,cols=c("black")) + geom_hline(yintercept = percent.mt1[i], linetype = 2)
  plot2 <- FeatureScatter(object.list[[i]], feature1 = "nCount_RNA", feature2 = "nFeature_RNA", pt.size = 0.1,cols=c("black")) + geom_hline(yintercept = nFeature_RNA1[i], linetype = 2)
  gg <- wrap_plots(plots = plot1, plot2, ncol = 2)
  print(gg)
  cowplot::save_plot(filename=paste0("QC2_", sample.name[i],"_.pdf"), plot=gg, base_width = 10, base_height = 3.5)
  object.list[[i]] <- subset(object.list[[i]], subset = (nFeature_RNA < nFeature_RNA1[i]) & (nCount_RNA < nCount_RNA1[i]) & (percent.mt < percent.mt1[i]))
}
lapply(object.list, function(x) dim(x@assays$RNA@data))
```

### Normalizing, scaling the data and feature selection
```{r, warning=FALSE}
object.list <- lapply(X = object.list, FUN = function(x) {
  x <- NormalizeData(x, verbose = FALSE)
  x <- FindVariableFeatures(x, verbose = FALSE, nfeatures = 3000)
 #x <- FindVariableFeatures(x, selection.method = "mean.var.plot", verbose = FALSE, mean.cutoff = c(0.01, 5), dispersion.cutoff = c(0.25, Inf))
  # perform scaling on the previously identified variable features
  x <- ScaleData(x, verbose = FALSE)
})
```


# Part II: Perform an integrated analysis using scMC
```{r,message=FALSE,warning=FALSE}
future::plan("multiprocess", workers = 4)
options(future.rng.onMisuse="ignore")
```
## Step2. identify clusters with different resolution for each condition
```{r,message=FALSE,warning=FALSE}
# compute SNN
object.list <- identifyNeighbors(object.list)
# identify clusters
object.list <- identifyClusters(object.list)
```

## Step3. detect cluster-specific cells with high confident
```{r}
features.integration = identifyIntegrationFeatures(object.list)
object.list <- identifyConfidentCells(object.list, features.integration)
```

## Step4. Identify marker genes associated with the putative cell clusters in each dataset
```{r}
object.list <- identifyMarkers(object.list)
```

## Step 5. Learn technical variation between any two datasets
```{r}
structured_mat <- learnTechnicalVariation(object.list, features.integration)
```

## Step 6. Learn a shared embedding of cells across all datasets after removing technical variation

```{r}
combined <- merge(x = object.list[[1]],y = object.list[2:length(x = object.list)])
combined@meta.data <- combined@meta.data %>% select(-starts_with("RNA_snn_res"))
combined$sample.name <- factor(combined$sample.name, levels = sample.name)
VariableFeatures(combined) <- features.integration
combined <- integrateData(combined, structured_mat)
```


# Part III: Run the standard workflow for visualization and clustering
## Run the standard workflow for clustering
```{r,message=FALSE,warning=FALSE}
nPC = 40
combined <- FindNeighbors(combined, reduction = "scMC", dims = 1:nPC)
combined <- FindClusters(combined, algorithm = 4, resolution = 0.05)
levels(Idents(combined))
combined <- BuildClusterTree(combined, reorder = T, reorder.numeric = T, verbose = F)
combined <- RunUMAP(combined, reduction='scMC', dims = 1:nPC)
```
### Quick visualization of cells onto the low-dimensional space
```{r, fig.width=8,fig.height = 3.5,  fig.wide = TRUE, fig.align = "center"}
dimPlot(combined, reduction = "umap", group.by = c("sample.name","ident"))
```
### Quick exploration of the marker genes
```{r, fig.width=6,fig.height = 8,  fig.wide = TRUE, fig.align = "center"}
combined <- ScaleData(combined, feature = rownames(combined), verbose = FALSE)
markers <- FindAllMarkers(combined, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
Misc(combined, slot = 'markers') <- markers
top10 <- markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
doHeatmap(combined, features=top10$gene, group.by='ident', additional.group.by = c('sample.name'))
```

## Visualization and annotation
### Feature plot of known marker genes
```{r, fig.width=7, fig.height=5.5,  fig.wide = TRUE, fig.align = "center"}
features = c('Lox','Ptch1','Cd68','Pecam1','Myh11','Plp1')
gg <- featurePlot(combined, features = features, show.legend = F, show.axes = F)
gg <- patchwork::wrap_plots(plots = gg, ncol = 3)
gg
cowplot::save_plot(filename=paste0("overlayKnownMarkers_integration_dermis", "_umap.pdf"), plot=gg, base_width = 5.5, base_height = 6)
```

### Annotation
```{r,message=FALSE,warning=FALSE}
new.cluster.ids <- c("Immune", "Hh-inactive Fib", "Hh-active Fib",  "Schwann", "Endotheial","Muscle")
names(new.cluster.ids) <- levels(combined)
combined <- RenameIdents(combined, new.cluster.ids)
new.order <- c("Hh-inactive Fib", "Hh-active Fib","Immune","Endotheial", "Muscle", "Schwann")
combined@active.ident <- factor(combined@active.ident, levels = new.order)
```

### Visualize cells onto the low-dimensional space
```{r, fig.width=9.5,fig.height = 3.5,  fig.wide = TRUE, fig.align = "center"}
p1 <- dimPlot(combined, reduction = "umap", group.by = "sample.name", colors.ggplot = T)
p2 <- dimPlot(combined, reduction = "umap", label = F)
gg <- patchwork::wrap_plots(p1, p2, ncol = 2)
gg
cowplot::save_plot(filename=paste0("integration_dermis", "_umap.pdf"), plot=gg, base_width = 8, base_height = 3)
# Split the plot into each dataset
dimPlot(combined, reduction = "umap", split.by = "sample.name",  combine = T)
```

### Heatmap of marker genes
```{r, fig.width=6,fig.height = 9,  fig.wide = TRUE, fig.align = "center"}
markers <- FindAllMarkers(combined, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
Misc(combined, slot = 'markers') <- markers
top10 <- markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
doHeatmap(combined, features=top10$gene, group.by='ident', additional.group.by = c('sample.name'))
```

### Violin plot
#### Stacked violin plot
```{r, fig.width=5,fig.height = 5,  fig.wide = TRUE, fig.align = "center", message=FALSE,warning=FALSE}
features = c('Lox','Ptch1','Cd68','Pecam1','Myh11','Plp1')
gg <- StackedVlnPlot(combined, features = features)
gg
cowplot::save_plot(paste0("violin_markers", "_integration_dermis", ".pdf"), gg, base_height = 3.5, base_width = 2)
```

#### Splitted violin plot
```{r, fig.width=5,fig.height = 5,  fig.wide = TRUE, fig.align = "center",message=FALSE,warning=FALSE}
features = c('Lox','Ptch1','Cd68','Pecam1','Myh11','Plp1')
gg <- StackedVlnPlot(combined, features = features, split.by = "sample.name")
gg
```

#### Violin plot with statistical test
```{r, fig.width=9,fig.height = 3,  fig.wide = TRUE, fig.align = "center", message=FALSE,warning=FALSE}
features = c('Pdgfra','Lox','Ptch1','Gli1')
gg <- vlnPlot(combined, features = features, stat.add = T, comparisons = list(c("Hh-inactive Fib", "Hh-active Fib")))
patchwork::wrap_plots(plots = gg, ncol = 4)
```

### Dot plot
```{r, fig.width=5,fig.height = 3.5,  fig.wide = TRUE, fig.align = "center"}
dotPlot(combined, features =c('Lox','Ptch1','Cd68','Pecam1','Myh11','Plp1'))
```

#### Splitted Dot plot
```{r, fig.width=4,fig.height = 3,  fig.wide = TRUE, fig.align = "center"}
dotPlot(combined, features = c('Pdgfra','Lox','Ptch1','Gli1'), split.by = "sample.name", idents = c("Hh-inactive Fib", "Hh-active Fib"))
```

# Part IV: Downstream analysis
```{r, message=FALSE,warning=FALSE}
combined$clusters.final <- Idents(combined)
```
## Compute the proportion
```{r, fig.width=7,fig.height = 3.5,  fig.wide = TRUE, fig.align = "center"}
gg1 <- computeProportion(combined, x = "clusters.final", fill = "sample.name")
gg2 <- computeProportion(combined, x = "sample.name", fill = "clusters.final", colors.use = scPalette(6))
gg1 + gg2
```

## DEG analysis
```{r, fig.width=3,fig.height = 4.5,  fig.wide = TRUE, fig.align = "center"}
markers.sample <- identifyDEG(combined, group.by = "sample.name")
```

## GO entichment analysis
```{r, fig.width=6,fig.height = 4.5,  fig.wide = TRUE, fig.align = "center"}
res.go <- getEnrichedGO(markers, category = "BP", do.simplify = F, idents = c("Hh-inactive Fib", "Hh-active Fib"))
```

# Save data
```{r, message=FALSE,warning=FALSE}
combined <- ScaleData(combined)
combined$clusters.final <- Idents(combined)
save(combined, file = "scMC_dermis_SeuratV4.RData")
# combined.loom <- as.loom(combined, filename = "scMC_dermis_SeuratV4.loom", verbose = FALSE)
# combined.loom$close_all()
write.table(GetAssayData(combined),file = "preprocessedData_integration_dermis.txt",sep = '\t')
write.table(combined@meta.data,file = "metaData_integration_dermis.txt",sep = '\t')
write.table(Idents(combined),file = "identity_integration_dermis.txt",sep = '\t')
write.table(Embeddings(combined, "scMC"),file = "integratedSpace_scMC_integration.txt",sep = '\t')
write.table(combined[["umap"]]@cell.embeddings,file = "projectedData_umap_integration_dermis.txt",sep = '\t')
write.table(markers,file = "markers_integration_dermis.txt",sep = '\t')
write.table(top10,file = "markersTop10_integration_dermis.txt",sep = '\t')

# combined.loom <- loomR::connect(filename = "scMC_dermis_SeuratV4.loom", mode = "r")
# combined <- as.Seurat(combined.loom)
```
